# 框架合并文档

> 项目适配说明（2026-02-04）
> - 采用 `.ux` 单文件组件（template/script/style），入口为 `src/app.ux`。
> - 页面位于 `src/pages/*`，常用生命周期：`onInit`、`onShow`、`onDestroy`。
> - 全局状态通过 `this.$app.$def.data` 共享（播放状态、主题、订阅）。
> - 主题与快照使用 `kv_storage` 持久化：`current_theme_id`、`theme_snapshot`。
此文档合并了 C:/Users/lxslx/Desktop/docs/usable\框架 目录下的所有MD文件。

## UX_文件.md

## UX 文件
============================================================================================

APP，页面均通过 ux 后缀文件编写，ux 后缀文件由template 模板、style 样式和script 脚本3 个部分组成，一个典型的页面 ux 后缀文件示例如下：

```
<template>
  <!-- template里只能有一个根节点 -->
  <div class="page">
    <text class="title">欢迎打开{{title}}</text>
    <!-- 点击跳转详情页 -->
    <input class="btn" type="button" value="跳转到详情页" onclick="routeDetail">
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }

  .title {
    font-size: 30px;
    text-align: center;
  }

  .btn {
    width: 400px;
    height: 60px;
    margin-top: 75px;
    border-radius: 43px;
    background-color: #09ba07;
    font-size: 30px;
    color: #ffffff;
  }
</style>

<script>
  import router from '@system.router'

  export default {
    private: {
      title: '示例页面'
    },
    routeDetail () {
      // 跳转到应用内的某个页面，router用法详见：文档->接口->页面路由
      router.push ({
        uri: '/DemoDetail'
      })
    }
  }
</script>
```

## app.ux

当前`app.ux`编译后会包含`manifest配置信息`（可以在`npm run build`之后查看文件内容），所以请不要删除`/**manifest**/`的注释内容标识。

您可以在`<script>`中引入一些公共的脚本，并暴露在当前 app 的对象上，如下所示，然后就可以在页面 ux 文件的 ViewModel 中，通过`this.$app.$def.util`访问。

```
<script>
  /**
   * 应用级别的配置，供所有页面公用
   */
  import util from './util'

  export default {
    showMenu: util.showMenu,
    createShortcut: util.createShortcut,
    util
  }
</script>
```

app.ux


---

## 内存优化.md

## 内存优化
==================================================================================================================

由于运动手表整体内存较小，对于三方应用内存占用量要求比较高。根据之前遇到的问题，给出一份三方应用开发时的注意事项清单，以帮助开发者尽量降低应用的内存占用，符合手表应用验收标准。

## 代码注意事项

1.   和 UI 无关，不需要绑定的数据，不要声明到 viewModel 的数据里，减少 observer 或者数据代理

```
<template>
  <div>
    <text>{{name}}</text>     
  </div>
</template>

<script>
  const someObj = { a: 1 } // 推荐写法
  export default {
    protected: {
      name: 'aaa',
      someObj: { // 不推荐写法
        a: 1
      }
    }
  }
</script>
```

1.   页面对象更新时，尽量原地更新，不要重新赋值，开辟新的内存空间

```
export default {
  protected: {
    list: [{
      name: 'aa',
      age: 22
    }]
  },
  
  onClick() {
    // 不推荐写法
    this.list = [{
      name: 'bb',
      age: 21
    }]
    // 推荐写法
    this.list[0].name = 'bb',
    this.list[0].age = 21
  }
}
```

1.   页面中声明的属性和方法不要缓存到全局上

页面销毁时，为清理内存，会将页面对象相关的属性和方法尽量解除引用。如果被引用到全局，就无法清理其占用的内存，并且在其他地方调用该缓存的属性和方法，可能引起报错。

```
export default {
  protected: {
    list: [{
      name: 'aa',
      age: 22
    }]
  },
  
  onShow() {
    this.$app.$def.somearray.push(this.foo) // 不推荐写法
  }，
  
  foo() {
    this.list.push({
      name: 'bb',
      age: 21
    })
  }
}
```

1.   页面销毁时，清除未执行完的定时器

```
export default {
  protected: {
    timer: null
  }
  
  onShow() {
    this.timer = setTimeout(()=>{}, 1000000)
  }
  
  onDestroy() {
    if(this.timer){
      clearTimeout(this.timer)
    }
  }
}
```

1.   读取文件数据，用完后及时释放

```
let foo = await storage.getItem('key')
let bar = await file.readText('path')

let fooObj = JSON.parse(foo)
let barObj = JSON.parse(bar)

// 用完后及时释放
foo = null
bar = null

fooObj = null
barObj = null
```

1.   调用runGC方法

通过执行全局对象global上的runGC方法，及时进行垃圾回收，避免内存泄漏。不要频繁调用，防止页面卡顿。

```
global.runGC()
```

1.   `static`属性

`template`模板中提供了`static`属性支持，如果绑定的变量后面不会再改变，添加`static`标记有助于框架减少实现动态节点，减少内存，也会降低页面销毁删除对象的时间。

```
<template>
  <div>
    <text static >{{name}}</text>
    <image static src="/assets/icon/a.png"/>   
  </div>
</template>

<script>
  export default {
    protected: {
      name: 'aaa'
    }
  }
</script>
```

另外，还支持在 `template` 上使用`.static`修饰符修饰节点的某个静态属性，适用于节点的该属性值仅在初始时被赋值一次，之后不会再变更。使用语法：`attr.static="{{ attrValue }}"`

注意

*   节点的 `if` / `for` 静态属性只能通过 `.static` 修饰词进行修饰
*   节点的 `static` 属性优先级比 `.static`高。对于声明了 `static` 属性的节点，可以不需要额外声明某个属性的静态修饰词 `attr.static`

```
<template>
  <div>
    <div if.static="{{ bool }}">
      <text style="{{ styl }}" someattr="{{ some }}" class="{{ cls }}" static>{{name}}</text>

      <input style="{{ styl }}" name="{{ some }}" class="{{ cls }}" value="{{ name }}" static />
    </div>

    <text
      if.static="{{ bool }}"
      style.static="{{ styl }}"
      someattr.static="{{ some }}"
      class.static="{{ cls }}"
      value.static
    >{{name}}</text>

    <input
      if.static="{{ bool }}"
      style.static="{{ styl }}"
      someattr.static="{{ some }}"
      class.static="{{ cls }}"
      value.static="{{name}}"
    />
  </div>
</template>

<script>
  export default {
    private: {
      name: 'aaa',
      bool: true,
      cls: 'basic-text',
      some: 'someattr',
      styl: {
        backgroundColor: '#d1d1d1'
      }
    }
  }
</script>
```

```
<template>
  <!-- block 内部节点数据只计算一次只渲染一次 -->
  <block static>
    <text class="{{cls}}">标题： {{title}}</text>
    <text>条件渲染</text>
    <list>
      <list-item for="{{list}}" type="item">
        <text>{{$item}}</text>
      </list-item>
    </list>
  </block>
</template>
<script>
  export default {
    private: {
      title: '我是标题1',
      cls: 'txt-cls',
      display: true,
      list: ['a', 'b', 'c']
    }
  }
</script>
```

## 减少打包代码体积

1.   减少不必要的三方依赖，选用轻量的三方依赖

对于`package.json`中的三方依赖，去除没有用到的依赖，对于必要的大型依赖，尽可能替换成轻量的依赖。

1.   使用全局方法

将通用的方法、常量和对象实例统一挂在`global`上，在页面中不用再`import`，需要用的时候直接从`global`上取。

```
// global.js
import foo from './foo'
import bar from './bar'

global.foo = foo
global.bar = bar

// app.ux
import  './global'

// pages/xxx/index.js
const {foo, bar} = global

export default {
    // 调用foo、bar
    //......
}
```

以QQ音乐为例，以下为优化前后效果对比：

|  | 优化前 | 替换轻量级依赖 | 使用全局方法 |
| --- | --- | --- | --- |
| 代码行数 | 21965 | 13156 | 6807 |
| 最大内存 | 4842844 | 3295928 | 1872528 |

1.   在保证图片质量的前提下，尽量用低分辨率图片

 大尺寸图片在加载时会占用较多内存，可以先将大尺寸图片缩放成小尺寸图片，再进行压缩(https://tinypng.com(opens new window))，减少图片的体积。

2.   去除没有用到的css和js

 对于css中没有用到的样式，js中没有用到的变量和函数，可以删除或者注释，精简代码。

3.   尽可能减少页面数量

 在不影响业务需求的前提下，用最少的页面去实现，减少代码体积，简化应用逻辑。

代码注意事项

减少打包代码体积


---

## 动态组件.md

## 动态组件
===============================================================================================================================

提示

**示例如下：**

```
<import src="./part1.ux" name="part1"></import>
<import src="./part2.ux" name="part2"></import>
<import src="./part3.ux" name="part3"></import>
<template>
  <div>
    <part1 if="{{status === 1}}"></part1>
    <part2 elif="{{status === 2}}"></part2>
    <part3 else></part3>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        status: 1
      }
    }
  }
</script>
```

**示例如下：**

```
<import src="./part1.ux" name="part1"></import>
<import src="./part2.ux" name="part2"></import>
<import src="./part3.ux" name="part3"></import>
<import src="./part4.ux" name="part4"></import>
<import src="./part5.ux" name="part5"></import>
<import src="./part6.ux" name="part6"></import>

<template>
  <div>
    <component is="{{'part' + status}}"></component>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        status: 1
      }
    }
  }
</script>
```


---

## 后台运行.md

## 后台运行
================================================================================================================================

为了节省系统资源，通常情况下，应用切换到后台后将会停止运行，等到再次切换回前台时重新运行。但音乐\运动等类型的应用，退到后台后可能仍然需要继续运行，为满足此类需求，加入了对后台运行的支持。后台运行模式的工作原理如下：

在应用切换到后台时，系统将会检查是否满足后台运行的条件，如果满足，应用将继续运行，否则将被停止。此条件包括：

1.   `manifest.json`中声明了后台运行接口

2.   当前至少有一个（已在`manifest.json`中声明的）后台运行接口正在运行

实践建议：

*   后台运行需要消耗较多的系统资源，应用需要根据自身需求审慎使用。针对申请后台运行的应用，上线审核时将会审核其后台运行的需求是否合理。
*   后台运行接口的导入和后台执行的工作放到`app.ux`中，而不是放到页面中，以免避免页面切换和销毁的影响。

## 配置方法

manifest.json 中声明所需的后台运行接口。后台运行接口包括：

1.   音频播放： `system.audio`
2.   上传下载： `system.request`
3.   地理位置： `system.geolocation`

```
{
  "package": "com.hybrid.demo.sample",
  //  ......

  "config": {
    "logLevel": "trace",
    "background": {
      "features":[
        "system.audio",
        "system.request"
      ]
    }
  }
  //  ......
}
```

配置方法


---

## 启动时延优化.md

## 启动时延优化
=====================================================================================================================================

## 避免setTimeout延迟

logo页如非必要，在执行页面跳转时，不要增加setTimeout延迟跳转。如果是需要等待异步结果返回，例如获取storage后决定跳转的下一个页面，建议将异步方法封装成同步，使用await，等待结果返回后立即执行跳转。以storage为例：

```
// ❌不推荐写法
onInit(){
  this.checkifHome()
  setTimeout(() => {
    if(!this.ifHome){
      router.push({uri:'pages/home'})
    }
  },1000)
}
checkifHome(){
  const that = this 
  storage.get({
    key: 'ifHome',
    success: function(data) {
      that.ifHome = data
    },
    fail: function(data, code) {
      console.log(`handling fail, code = ${code}`)
    }
  })
}
```

```
// ✅推荐写法一
onInit(){
  storage.get({
    key: 'ifHome',
    success: function(data) {
      if(!data){
        router.push({uri:'pages/home'})
      }
    },
    fail: function(data, code) {
      console.log(`handling fail, code = ${code}`)
    }
  })
}
```

```
// ✅推荐写法二
async onInit(){
  const ifHome = await checkifHome()
  if(!ifHome){
    router.push({uri:'pages/home'})
  }
}
checkifHome(){
  return new Promise((resolve, reject) => {
    storage.get({
      key: 'ifHome',
      success: function(data) {
        resolve(data) 
      },
      fail: function(data, code) {
        console.log(`handling fail, code = ${code}`)
        reject(code)
      }
    })
  })
}
```

```
// ✅推荐写法三
//可统一封装promise.js,方便其他异步接口复用
export function promisify(fn) {
  if (typeof fn !== 'function') {
    throw Error('[promisify] the type of `fn` should be function');
  }

  return (opts={}) => {
    let { success, fail, complete, ...args } = opts;

    if (typeof success === 'function' || typeof fail === 'function' || typeof complete === 'function') {
      console.warn('[promisify] [WARN] The `success`, `fail` and `complete` callback will be ignored');
    }

    return new Promise((resolve, reject) => {
      try {
        fn({
          ...args,
          success: data => resolve(data),
          fail: (data, code) => {
            let err = new Error(data);
            err.code = code;
            reject(err);
          }
        });
      } catch (error) {
        reject(error)
      }
    })
  }
}

//统一封装storage方法
import storage from '@system.storage';
import {promisify} from './promise';

const _get = promisify(storage.get);
const _set = promisify(storage.set);
const _clear = promisify(storage.clear);
const _delete = promisify(storage.delete);
export default {
  getItem(key) {
    return _get({key});
  },

  setItem(key, value) {
    return _set({key, value});
  },

  deleteItem(key) {
    return _delete({key});
  },

  clear() {
    return _clear();
  },
}

//logo.ux
async onInit(){
   const ifHome = await storage.getItem('ifHome')
  if(!ifHome){
     router.push({uri:'pages/home'})
  }
}
```

## 首页数据缓存

首页数据如果二次进入，需要再次展示的，可以考虑在应用（或首页）退出时增加上缓存，下次进入从logo页读取缓存后将数据存储在全局，首页page在onInit时直接读取，然后同时发起异步请求进行更新即可；

## logo页避免http请求

建议不要在logo页引入http请求，尽可能放到首页执行，防止弱网或者无网情况阻塞页面跳转；

## UI先行

如音乐类应用，进入应用建议默认状态为不播放，可以UI先行，如果歌曲信息获取成功立即展示，无需等到audio资源加载完成展示；

## 隐私页信息使用静态数据

隐私页的数据代码里使用静态的数据，不用动态获取。需要展示长文本的，可以通过二维码扫码查看，二维码直接本地写死一个h5链接，不要通过接口去获取；

## 减少从console打印

尽可能减少console打印，特别是长日志，很影响性能，避免很长的（>10行）console打印，尽可能减少json对象的打印，如果是debug期间需要打印日志，建议使用console.debug，并且配置quickapp.config.js（具体配置如下），在打release包的时候过滤掉console.debug的日志；

```
const TerserPlugin = require("terser-webpack-plugin")
const webpack = require("webpack")

module.exports = {
  postHook: (config) => {
    if (config.mode === "production") {
      config.optimization.minimize = true
      config.optimization.minimizer = [
        new TerserPlugin({
          terserOptions: {
            compress: {
              pure_funcs: ["console.debug"]
            }
          }
        })
      ]
    }
  }
}
```

## 图片缓存/裁剪

如果有较大的（>100kb）动态图片，建议首次加载增加loading页，下载并缓存到本地，后续通过internal://files/XXX.png加载（重要：一般非必要不建议引入在线大图，引入的大图尺寸也不要超过屏幕尺寸，且大小不超过200kb，尽量使用本地图片代替在线图片，或者在线图片里支持resize-尺寸裁剪）

```
//login.ux
export function downloadFile(url) {// 下载图片
  return new Promise((resolve, reject) => {
    if(!url){
      resolve('')
    }
    request.download({
      url,
      success: function (ret) {
        const token = ret.token
        request.onDownloadComplete({
          token: token,
          success: function (ret) {
            console.info(`### request.download ### ret`,ret)
            resolve(ret.uri)
          },
          fail: function (msg, code) {
            console.info(`### request.onDownloadComplete ### ${code}: ${msg}`)
            resolve(null)
          }
        })
      }
    })
  })
}
const formUrl = 'http://XXX.cdn.homeBg.png'
downloadFile(formUrl).then(url => {
  global.homeBgUrl = url; //url => 'internal://files/homeBg.png'
})
 
//home.ux
<image class="w-466 h-466" src="{{bgImage}}" alt="../../common/images/homeBg.png"></image>
//....
  computed:{
    bgImage() {
      const img =  global.homeBgUrl || 'http://XXX.cdn.homeBg.png'
      return img
    }
  }
//....
 
 //logo页
 global.homeBgUrl = await storage.getItem('homeBgUrl')
 
 //根据条件变化，及时进行图片清理
 logoOut(){
   file.delete({
    uri:global.homeBgUrl,
    success: function(data) {
      console.info(`###delFile sucess ${data}`)
      resolve(true)
    },
    fail: function(data, code) {
      resolve(false)
      console.log(`###delFile fail, code = ${code}`)
    }
  })
}
```

## 通信类应用通信之前使用diagnosis方法判断连接状态

使用interconnect实现手表app和手机app的通信时，摒弃之前的轮询调用getApkStatus方法，改用新api diagnosis

```
data: {
   status: '',
   connectNum: 3,
   conn: null
},
onInit() {
   this.conn = interconnect.instance();
   this.connectStatus();
},
```

```
// ❌ 不推荐写法
connectStatus() {
  let status = this.conn.getApkStatus();
  if (status === 'CONNECTED' || this.connectNum === 0){
    this.status = status;
    // do something
  } else if (this.connectNum > 0) {
    this.connectNum --;
    setTimeout(() => {
      this.connectStatus()
    },500)
  }
}
```

```
// ✅推荐写法
connectStatus() {
  this.conn.diagnosis({
    success: (data) => {
      console.log(`handling success, status= ${data.status}`)
      // do something
    },
    fail: (data,code) => {
      console.log(`handling fail, code = ${code}`)
      // do something
    }
  })
}
```

## 使用interconnect传输多条数据

手表app向手机app传输多条数据时，若传输数量不大，建议直接一次性发送，无需增加延迟发送

```
// ❌不推荐写法
sendMsg(list) {
  for (let x in list) { 
    setTimeout(() => {
      this.conn.send({
        data: list[x],
        success: ()=>{ },
        fail: (data: {data, code})=> { }
      })
    },x*500) 
  }
}
```

```
// ✅推荐写法
sendMsg(list) {
  for (let x in list) {            
    this.conn.send({
      data: list[x],
      success: ()=>{ },
      fail: (data: {data, code})=> { }
    })
  }
}
```

避免setTimeout延迟

首页数据缓存

logo页避免http请求

UI先行

隐私页信息使用静态数据

减少从console打印

图片缓存/裁剪

通信类应用通信之前使用diagnosis方法判断连接状态

使用interconnect传输多条数据


---

## 多语言覆盖.md

## 多语言覆盖

Vela 的能力会覆盖多个国家地区，框架支持多语言的能力后，可以做到让一个JS 应用产品（一个 RPK 文件）同时支持多个语言版本的切换，开发者无需开发多个不同语言的源码项目，避免给项目维护带来困难。

使用系统默认的语言，开发者配置多语言的方式非常简单，只需要`定义资源`与`引用资源`两个步骤即可。

## 定义资源文件

资源文件用于存放多个语言的业务信息定义，与其它技术平台类似（它们使用`properties文件`或者`xml文件`的格式），JS 应用平台使用`JSON文件`保存资源定义；

在项目源码`src目录`下定义`i18n文件夹`，内部放置每个语言地区下的资源定义文件即可。

##### 资源文件命名查找规则及建议

文件命名可使用当前系统获取到的语言以及国家信息，例如文件名可定义为：`zh-CN.json`、`zh.json`。

如果开发者当前产品仅计划支持一种语言，同时还希望用到多语言能力，那么仅声明一个名称为`defaults.json`的文件即可。

JSON文件名匹配优先级，优先级高的匹配到就停止查找，否则就向下一级查找。

**优先级匹配规则**如下：

`<语言代码>-<国家代码>`

`<语言代码>`

`defaults`

默认i18n配置文件首个文件

**命名建议**：

*   如果需要精确匹配语言+地区进行多语言配置建议使用`<语言代码>-<国家代码>.json`命名资源文件；

*   不需要匹配地区的建议使用`<语言代码>.json`命名资源文件；

*   `defaults.json`可以作为默认选项单独使用，也可配合以上两种方式结合使用；

*   不推荐使用系统最终的兜底默认首个文件的方案，可能会造成不符合预期的显示结果。

##### 资源文件支持的配置语法

###### 基础文本配置

###### 数组配置

匹配到会把数据内容序列化转成文本输出，此种配置不支持与插值语法混用。

###### 命名插值配置

支持使用`{}`占位符进行命名插值，调用时通过具名参数传入替代占位内容。

###### 列表插值配置

支持使用`{}`占位符进行列表插值，通过配置列表取值索引，在调用时传入备选列表进行取值替代占位内容。

###### 单复数语法配置

支持使用`|`占位符进行单复数语法配置，不同的选择项使用占位符分隔。

## 页面中引用资源

使用多语言配置的方式主要通过ViewModel 实例上`$t`与`$tc`函数实现，这些方法可以在`<template>`或`<script>`中使用。

##### 简单格式化方法

this.$t(path, opts)

**参数说明**：

| 参数 | 类型 | 是否必填 | 说明 |
| --- | --- | --- | --- |
| path | String | 是 | 获取多语言配置的资源路径，对象取值通过.连接，例如：”message.hello“ |
| opts | Array | Object | 否 | 进行插值替换的配置项，可以传入对象或数组，配合配置中的差值配置使用 若传入对象则需要指定配置的命名key进行传参 若传入数组取值为传入列表对应的列表插值配置的index值 |

**使用示例**：

使用**基础文本配置**对应取值示例：

使用**数组配置**对应取值示例：

使用**命名插值配置**对应取值示例：

使用**列表插值配置**对应取值示例：

##### 单复数格式化方法

this.$tc(path, choice, opts)

**参数说明**：

| 参数 | 类型 | 是否必填 | 说明 |
| --- | --- | --- | --- |
| path | String | 是 | 获取多语言配置的资源路径，对象取值通过.连接，例如：”message.hello“ |
| choice | Number | 否 | 用于判断使用第几个选项的值，不传具体值时默认单数，在不传入第三个参数时也可用作插值显示 **特殊值说明**： 值必须是整数，错参报错不显示返回空字符串 单复数判断忽略正负符号 两段式0作为偶数处理 |
| opts | Array | Object | 否 | 进行插值替换的配置项，可以传入对象或数组，配合配置中的差值配置使用 若传入对象则需要指定配置的命名key进行传参 若传入数组取值为传入列表对应的列表插值配置的index值 |

**choice单复数配置说明**：

目前单复数在资源文件中支持两种写法并支持与插值语法混用。

两段式配置：单数|复数；

三段式配置：空值|单数|复数。

**配置示例**：

**使用示例**：

## 获取系统语言

上面的能力用于资源内容的格式化，在某些场景下开发者可能需要获取当前系统的地区语言`locale`并进行更改，来完成不同的逻辑处理。比如：

*   不同的 locale 对应的页面布局不同；

*   开发者为用户提供设置某种语言的能力；

框架`system.configuration`提供了相关功能，文档参考：应用配置 configuration。

## 修改地区语言后的回调

当用户在系统设置切换地区语言，会触发 onConfigurationChanged 回调，且返回来的 event.type 值为locale。

详情可参考文档。

示例代码：


---

## 安装环境.md

## 下载 AIoT-IDE

本应用支持 **macOS**、**Windows** 及 **Ubuntu** 系统，请确保设备满足以下最低系统版本要求。

* * *

## 系统要求

| 操作系统 | 最低版本要求 |
| --- | --- |
| **macOS** | 14（Sonoma）及以上 |
| **Windows** | 10 或更高版本 |
| **Ubuntu** | 20.04 LTS 或更高版本 |

## 安装 AIoT-IDE

mac 版本下可能会遇到如下安装报错的问题:

![Image 1: alt text](https://iot.mi.com/vela/quickapp/images/ide/ide-download-1.png)

遇到此类问题，请按下面方法操作：

1.打开 shell 窗口，输入 ：`sudo xattr -r -d com.apple.quarantine`,如下图示例一。

 2.敲入空格 **再将应用程序拖入到窗口中**，会得到下图示例二。

 3.点击回车，输入密码，再执行该程序即可。

![Image 2: alt text](https://iot.mi.com/vela/quickapp/images/ide/ide-download-2.png)

示例一

![Image 3: alt text](https://iot.mi.com/vela/quickapp/images/ide/ide-download-3.png)

示例二

## 历史版本

历史版本地址：点击查看(opens new window)

 密码：99E6

## 使用 AIoT-IDE

##### 1. 初始化 Vela 项目

*   通过点击左上角 「文件」 > 「新建项目」 打开项目初始化图形界面
*   点击卡片左侧边栏的 Vela，点击 「创建」
*   选择一个项目模版，点击 「下一步」
*   输入项目名称和项目保存路径后，点击「创建」，等待项目创建完成

##### 2. 项目开发

支持依赖安装、运行、调试、重启、模拟器管理和打包项目等功能。

 打开 Vela 快应用项目后，AIoT-IDE 会弹出顶部的 banner 操作按钮栏以及右侧的开发向导页，可根据开发向导的指引安装相关的依赖。

 依赖安装完成后，可点击 banner 栏里的操作按钮实现对应的功能。

##### 3. 开发向导指引

打开 Vela 快应用项目，AIoT-IDE 右侧会弹出开发向导，用于指导开发。可以根据向导的提示完成对应的操作。

按向导提示遇到 npm i 下载 npm 包失败,可按如下方法解决：

*   检查当前项目根目录中是否有.npmrc 文件,如果没有则自己创建。

![Image 9: alt text](https://iot.mi.com/vela/quickapp/images/ide/ide-npm-1.png)

*   打开.npmrc 文件,将下面内容复制到文件中

`registry="https://registry.npmmirror.com/"`

![Image 10: alt text](https://iot.mi.com/vela/quickapp/images/ide/ide-npm-2.png)

*   打开终端,在终端重新运行 npm i

![Image 11: alt text](https://iot.mi.com/vela/quickapp/images/ide/ide-npm-3.png)

##### 4. 模拟环境管理

AIoT-IDE 支持自动初始化模拟器环境，创建、删除和列表展示模拟器，以便在运行/调试时可以选择不同的模拟器查看效果。

**模拟器环境说明**

如果缺少模拟器环境和模拟器实例，开发向导中会给出需相应的提示

*   点击下方的「检查模拟器环境，创建模拟器实例」按钮，在弹出的模态窗口中选择 「自动安装」，插件会自动帮助安装模拟器相关的依赖
*   在模拟器列表页，点击左上角的「创建」按钮去生成一个模拟器实例

**模拟器操作说明**

*   查看已创建的模拟器

 点击 banner 栏的「模拟器」按钮，进入模拟器列表页，这里可以看到已经创建的模拟器的详细信息

*   创建一个新的模拟器 
    *   点击**设备管理**左上角的**新建**按钮，进入模拟器表单页
    *   在模拟器表单页，填写要创建的模拟器信息，点击「创建」按钮，插件首先会下载 Vela 镜像并完成创建

推荐使用 Vela 正式版（4.0）版本的镜像

##### 5. 运行项目

运行时首先需要选择要在哪个模拟器上预览效果，选择后则会将当前打开的快应用在模拟器中启动并显示项目 UI。

插件会过滤出`$HOME/.android/avd`这个目录下以“Vela”开头的所有模拟器，如果没有找到，AIoT-IDE 右下角会弹出提示，可点击「模拟器」按钮去进行创建。

##### 6. 调试项目

跟运行一样，调试时同样需要选择模拟器。

 快应用启动成功后，AIoT-IDE 底部会弹出调试面板，点击调试面板的 Tab 栏即可进行对应的操作，比如查看 DOM 树、查看 Console 以及断点调试。

##### 7. 打包项目

**开发模式打包**

 开发完成后，可以点击 banner 栏的「打包」按钮来打包应用，默认会生成两个新的目录：dist、build；

 其中 dist 文件夹中会生成一个`.debug.rpk`文件，build 中会生成编译后的 js 文件。

**生产模式打包**

*   打包前需要配置 signature private key ，生成签名文件

    *   自动生成：点击 banner 栏的「发布」按钮 > 填写相关信息 > 点击「完成」按钮，插件会在项目的 sign 目录下生成`private.pem`和`certificate.pem`两个文件。签名文件生成成功后，点击**顶部操作栏**栏的「发布」按钮，打包生成的产物跟开发模式打包类似，但是 dist 文件夹中的 rpk 文件是 release 后缀。

    *   自动生成需要系统环境安装了 openssl，windows 系统可能遇到 openssl 缺失的问题，下面是具体解决方法。

        *   安装 openssl 并配置系统环境变量，并重启电脑。重启成功后，在 AIoT-IDE 中打开终端，输入 openssl，如下图所示，则是安装成功。

    *   手动生成：前提同样是系统环境安装了 openssl,然后打开终端运行以下命令生成签名文件，项目下新建 sign 目录，将生成的文件 private.pem 和 certificate.pem 放至该目录

`openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem`


---

## 常用业务优化.md

## 常用业务优化
========================================================================================================================================

## list与长文案优化

说明

list过长以及长文案（例如大段的隐私协议，用户协议）显示时，所能用到的优化手段

*   list

list列表，在初始化渲染时，原则上，如果内容超过10条，建议使用分页式渲染，或是触底发送请求新的数据，切勿初始化渲染大量数据，会造成页面渲染卡顿。

*   长文案

长文案一般是需要在小的设备屏幕上显示大量的文字内容，例如“用户协议”，“隐私协议”，“未成年人保护协议”等等

    *   通常建议是用二维码显示协议链接，通过扫码在手机上浏览也是一种比较常用的设计。
    *   如果产品需要一次性全量渲染，会一定程度上造成页面的渲染卡顿，影响首次渲染的用户体验，这里推荐的是分块渲染文案。下面是代码示例：

```
<!-- 渲染文案的区域,同时绑定handleScroll滚动监听 -->
<template>
  <scroll id="scroll" scroll-y="true" class="scroll" onscroll="handleScroll">
    <div id="content" class="connent">
      <block if="{{currentKey >= 0}}">
        <text class="header-1">{{contentArray[0]}}</text>
      </block>
        <block if="{{currentKey >= 1}}">
        <text class="header-1">{{contentArray[1]}}</text>
      </block>
        <block if="{{currentKey >= 2}}">
        <text class="header-1">{{contentArray[2]}}</text>
      </block>
    </div>
  </scroll>
</template>
<!-- 把文案内容以数组形式保存，并记录当前所渲染的文案的序列号 -->
<script>
export default {
  data:{
    contentArray:[
      {
        content:'文案一..........'
      },
      {
        content:'文案二..........'
      },
      {
        content:'文案三..........'
      }
    ],
    //当前所需所渲染到的文案序列号
    currentKey:0,
    //当前总高度
    currentTHEight:0,
  }
  //onReady时先给当前总高度赋一次值
  onReady(){
    this.$element('content').getBoundingClientRect({
      success: (data) => {
        const { height } = data;
        this.currentTHEight = height
      }
    })
  }
  //实时判断滚动高度与总体高度，如果快触底了，则进行下一个文案的加载,同时给总高度重新赋值
  handleScroll(e) {
    if(currentTHEight - e.scrollY <40){
        this.currentKey = currentKey + 1
    }
    this.$element('content').getBoundingClientRect({
      success: (data) => {
        const { height } = data;
        this.currentTHEight = height
      }
    })
  }
}

</script>
```

## Swiper 多图优化

说明

当使用swiper轮播图时，如果图片很多。请避免同时渲染多张图片。保证可视区内以及左右图片的渲染即可

    1.   当用户点击第一张图，`swiper`中的数据为`data[0],data[1],data[2]`
    2.   当从第一张图片滑动到第二张图片的时候，`swiper`的数组仍然为`data[0],data[1],data[2]`

![Image 3: alt text](https://iot.mi.com/vela/quickapp/images/components/business-swiper.jpg)`Swiper懒加载实例`

*   具体实现思路

在代码中通过`@change`事件监听`swiper`的滑动。判断左滑右滑逻辑如下：

```
// 判断右滑
if (
  (!(this.currentIndex === 0 && index === length - 1) && index > this.currentIndex) ||
  (index === 0 && this.currentIndex === length - 1)
) {
}else{
}
```

右滑的逻辑如下：

```
//更新数据索引
this.dataIndex = this.dataIndex + 1
//更新下一次右滑的索引
const updateIndex = this.dataIndex + 1
if (updateIndex < this.bigThumbnailInfo.length) {
  //下一次右滑更新为当前的下一张
  updateItem = this.bigThumbnailInfo[updateIndex]
  // 如果滑动前是
  if (this.currentIndex === 0) {
    //未滑动前是第一张，右滑更新swiper的最后一个
    this.data[length - 1] = updateItem
    resIndex = length - 1
  } else {
    // console.info("右滑：更新左边的")
    this.data[this.currentIndex - 1] = updateItem
    resIndex = this.currentIndex - 1
  }
}
```

左滑代码逻辑如下：

```
//更新数据索引
this.dataIndex = this.dataIndex - 1
//更新下一次右滑的索引
const updateIndex = this.dataIndex - 1
//下一次左滑更新为当前的上一张
updateItem = this.bigThumbnailInfo[updateIndex]
if (this.currentIndex === length - 1) {
  //未滑动前在最后一张，左滑更新swiper第一个
  this.data[0] = updateItem
  resIndex = 0
} else {
  this.data[this.currentIndex + 1] = updateItem
  resIndex = this.currentIndex + 1
}
```

判断如果当前是最后一张图片代码如下：

```
this.data = [
  this.bigThumbnailInfo[len - 3],
  this.bigThumbnailInfo[len - 2],
  this.bigThumbnailInfo[len - 1]
]
indexTemp = 2
this.swiperIndex = this.currentIndex
this.isloop = false
```

判断即将更新的图片是第一张图片：

```
this.data = [
  this.bigThumbnailInfo[0],
  this.bigThumbnailInfo[1],
  this.bigThumbnailInfo[2]
]
indexTemp = 0
this.swiperIndex = this.currentIndex
this.isloop = false
```

如果不是第一张也不是最后一张图片，设置`swiper`的`loop`为`true`:

```
this.isloop = true
```

## 设备帧率的优化建议

*   有背景图或者图片的时候，尽量减少设置`border-radius`，使用带圆角的图片
*   减少`动态样式`修改
*   减少标签的`嵌套层级`
*   减少回流重绘

## 其他优化建议

*   增加try catch捕获异常
*   数据请求较慢的场景建议增加loading

list与长文案优化

Swiper 多图优化

设备帧率的优化建议

其他优化建议


---

## 常见问题.md

## 常见问题

## 如何适配不同尺寸的屏幕？

框架默认的屏幕分辨率是480*480，Vela三方应用会自动适配，开发者可以直接按照设计稿的尺寸来开发。 比如，设计稿是466*466，可以在`manifest.json`中配置`designWidth: 466`，然后css中尺寸相关的数值跟设计稿保持一致即可。 更多详细细节信息可以参考：页面样式和布局。

## 模拟器怎么跟手表通信？

模拟器跟手机通讯，需要外接蓝牙适配器，并且配置比较复杂，建议使用真机调试。

## 如何解决通信过程中提示签名不正确的问题？

手表和手机通信前会检查应用的签名，如果签名不正确通信会被拒绝。所以调试通信时需要手机app和手表rpk使用配套的证书打包。

 遇到签名不正确的错误时，请检查导出rpk时使用的证书是否和打包手机app时的证书相同。

## 如何排查通信(interconnect)相关的问题？

## 如何解决列表数据更新时闪烁的问题？

通过for循环渲染的列表，在数据更新时，如果出现闪烁，可以增加tid来解决。详细文档可以参考：循环指令。

## 构建release版本rpk时打包证书有什么要求？

1.   如果涉及手表跟手机通信，打包rpk时的证书需要跟打包手机app的证书一致，否则无法通信；
2.   如果不涉及通信，对证书无特殊要求，按照文档中的步骤生成即可；

> 注意：请妥善保管证书，并且保证每次使用相同的证书打release版本rpk包。如果证书改变，可能无法上架。

## 如何解决手表和手机连接状态获取问题？

进入页面直接获取状态往往会拿到`DISCONNECTED`，因此需要轮询获取状态，根据`getApkStatus()`的返回值，判断手表和手机的连接状态。

## 模拟器支持哪些平台？

模拟器支持Windows，Mac和Ubuntu三个平台，其中Windows支持Win10+，Mac支持macOS12+

## Windows和Mac是否可以打包rpk？

Windows和Mac可以打包rpk。

## 如何将rpk上传到手表真机运行?

1.   手机安装小米运动健康(目前是通过商务拉群对接的方式提供。开发vela三方应用需求，请邮件联系常健：changjian@xiaomi.com)；
2.   点击【小米运动健康】-->【我的】-->【关于】-->【Debug】；
3.   点击【第三方应用】；
4.   点击【Click to input package name】；
5.   随便输个字符（只有卸载时要详细包名）；
6.   选择【Install third app】；
7.   选择本地rpk文件安装；
8.   安装成功会有Toast提示。

## 如何查看手表真机上的日志？

1.   手机安装小米运动健康(目前是通过商务拉群对接的方式提供。开发vela三方应用需求，请邮件联系常健：changjian@xiaomi.com)；
2.   小米运动健康与手表进行同步；
3.   在手表上复现问题；
4.   点击【小米运动健康】-->【我的】-->【关于】-->【Debug】-->【拉取固件日志】；
5.   拉取成功后保存在手机，日志文件目录: `/sdcard/Android/data/com.mi.health/files/log`。


---

## 教程.md

## 概述

Xiaomi Vela JS 应用是小米公司开发的一种应用类型，它是基于小米的物联网嵌入式软件平台 Xiaomi Vela OS 开发的。本文将介绍 Xiaomi Vela JS 应用的特点、应用场景以及开发支持，帮助开发者更好地了解和使用这一应用类型。

如果您想快速了解如何开发 Xiaomi Vela JS 应用，并且希望快速上手，请直接访问 快速入门 章节。

## 应用特点

Xiaomi Vela JS 应用是一种基于 Xiaomi Vela OS 操作系统的轻量级应用模式，旨在为智能穿戴设备提供更加流畅和便捷的用户体验。它具备以下显著特点：

*   **轻量化：** Xiaomi Vela JS 应用采用了轻量级的架构设计，与传统的应用程序相比，Xiaomi Vela JS 应用具有更小的体积，这使得它们能够快速加载和运行，尤其适合内存和处理能力有限的穿戴设备。
*   **跨平台兼容性：** Xiaomi Vela JS 应用支持跨端运行，开发者可以一次开发，实现在多种设备上的运行，这大大提高了开发效率和应用的普及率。
*   **高性能渲染：** 系统优化了渲染能力，使得应用的动画和交互更为流畅，提升了用户的使用体验。
*   **安全性能：** Xiaomi Vela OS 通过三重隔离机制确保了应用的安全性，保护了用户数据和设备的安全。

## 应用场景

Xiaomi Vela JS 应用的应用场景广泛，已落地多款产品，覆盖了智能穿戴设备上的多种使用情形：

*   **健康监测：** 应用可以实时监测用户的心率、睡眠质量等健康数据，为用户提供健康建议和预警。
*   **运动辅助：** 在用户进行运动时，应用能够记录运动数据，提供运动指导和健康管理。
*   **消息提醒：** 应用能够显示手机等设备的消息提醒，方便用户在不拿出手机的情况下查看重要信息。
*   **移动支付：** 应用可以集成支付功能，用户可以直接在穿戴设备上完成支付操作，提高支付的便捷性。
*   **智能控制：** 作为智能家居的控制中心，应用可以远程操控家中的智能设备，如灯光、空调等。

## 技术优势

相较于传统的应用框架，Xiaomi Vela JS 应用具有以下技术优势：

##### 前端开发范式

Xiaomi Vela JS 应用采用JavaScript语言开发，并且支持前端MVVM高效的开发范式，响应式UI框架，易学易用。使得开发者可以降低上手难度，缩短开发周期。这种模式贴合主流前端开发者的思维习惯，使得开发者能够快速构建出功能丰富、交互友好的应用，同时降低了学习成本。参考开发语法。

##### 高性能渲染

*   通过架构优化，让复杂计算下沉到原生层，解决 JS 语言的性能瓶颈，从而拥有媲美原生的运行效率和流畅体验。
*   提供丰富的动效能力，包括30+插值和物理动效，可用于过渡、转场等动画效果，使用户界面更加生动、有趣和富有表现力。
*   充分挖掘硬件性能，最大限度利用 GPU 和 CPU 的硬件加速能力，让复杂UI 界面和动画更加流畅，达到 60 fps 满帧效果。

##### 多屏适配

多屏适配是Xiaomi Vela JS 应用框架的另一大特色，具体表现在：

*   **适配规范：** 框架支持不同形状、尺寸和分辨率的屏幕自适应，确保应用在各种设备上都能提供良好的视觉体验。
*   **设计规范：** Vela提供了一套多屏设计的技术规范，帮助开发者按照设计稿完成应用的多屏适配。
*   **多屏UI模拟器：** AIoT-IDE提供了多屏UI模拟器，使开发者能够快速预览应用在不同屏幕上的效果，进行必要的调整。
*   **适配案例：** 提供了对常见页面元素进行多屏适配的代码示例以及整站案例，供开发者参考和学习。

## 应用开发流程

##### 环境搭建

##### 应用开发

初始化项目后请参考项目结构了解项目中各文件和目录的作用。项目由配置文件（manifest.json）、模板代码（ux文件）、 样式代码（css文件）、逻辑代码（js文件）以及资源文件（图片、音频等）组成。请参考项目配置对项目相关信息进行配置。

##### 运行调试

AIoT-IDE提供内置的模拟器，支持开发者启动模拟器在IDE中直接运行和调试应用，实时查看运行效果。请参考运行调试了解如何运行和调试应用。

##### 打包发布

应用开发完成后，开发者可以使用AIoT-IDE提供的打包功能将应用打包成安装包，请参考打包项目了解如何打包应用。项目打包成功后请参考发布进行应用发布。


---

## 样式语法.md

## style 样式
=================================================================================================

为了解决屏幕适配问题，所有与大小相关的样式（例如 width、font-size）均以基准宽度（默认 480px）为基础，根据实际屏幕宽度进行缩放，例如 width:100px，在 960px 宽度屏幕上，width 实际上为 200px。

## 文件导入

支持 2 种导入外部文件的方式：

```
<!-- 导入外部文件, 代替style内部样式 -->
<style src="./style.css"></style>

<!-- 合并外部文件 -->
<style>
  @import './style.css';
  .a {
  }
</style>
```

## 模板内部样式

```
<!-- 内联inline -->
<div style="color:red; margin: 10px;"/>
<!-- class声明 -->
<div class="normal append"/>
```

## 选择器

支持的选择器有：

| 选择器 | 样例 | 样例描述 |
| --- | --- | --- |

```
<style>
  /* 单个选择器 */
  text {
  }
  .class-abc {
  }
  #idAbc {
  }
  /* 同一样式适应多个选择器 */
  .font-text, .font-comma {
  }
</style>
```

## 选择器优先级

当前样式的选择器的优先级计算保持与浏览器一致，是浏览器 CSS 渲染的一个子集（仅支持：inline, id, class, tag）。

多条 CSS 声明可以匹配到同一个元素 如 div，应用在该元素上的 CSS 声明总体优先级是：inline > #id > .class > tag，这四大类匹配到该元素的多个 CSS 声明，如：`<div id="sample" style="width: 200px;" class="class-div"></div>`，其优先级按照各选择器的权值高低之和来比较。选择器的优先级权值如下：

*   `ID选择器`（例如: #hello）的权值为 10000

*   `类选择器`（例如: .example）的权值为 100

*   `类型选择器`（例如: h1）的权值为 1

css 的优先级计算文档也可以查看MDN 文档(opens new window)入门

## 样式预编译

```
<!--导入外部文件, 代替style内部样式-->
<style lang="less" src="./lessFile.less"></style>

<!--合并外部文件-->
<style lang="less">
  @import './lessFile.less';
  .less-font-text, .less-font-comma {
    font-size: 60px;
  }
</style>
```

快速导航

文件导入

模板内部样式

选择器

选择器优先级

样式预编译


---

## 模板语法.md

## template 模板
==========================================================================================================

注意

模板中只能有 1 个根节点，如：div；请不要在`<template>`下存在多个根节点，也不要使用 block 作为根节点。

## 数据绑定

```
<template>
  <text>{{message}}</text>
</template>

<script>
  export default {
    private: {
      message: 'Hello'
    }
  }
</script>
```

## 事件绑定

```
<template>
  <div>
    <!-- 正常格式 -->
    <text onclick="press"></text>
    <!-- 缩写 -->
    <text @click="press"></text>
  </div>
</template>

<script>
  export default {
    press(e) {
      this.title = 'Hello'
    }
  }
</script>
```

事件回调支持的写法（其中`{{}}`可以省略）：

**fn**：`fn`为事件回调函数名（在`<script>`中有对应的函数实现）；

**fn(a,b)**：函数参数例如`a`，`b`可以是常量，或者是在`<script>`中定义的页面的数据变量（前面不用写`this`）；

## 列表渲染

```
<template>
  <div>
    <div for="{{list}}" tid="uniqueId">
      <text>{{$idx}}</text>
      <text>{{$item.uniqueId}}</text>
    </div>
  </div>
</template>

<script>
  export default {
    private: {
      list: [
        { uniqueId: 1 },
        { uniqueId: 2 }
      ]
    }
  }
</script>
```

`for指令`根据源数据数组渲染列表，支持的写法如下（其中`{{}}`可以省略）：

*   `for="{{list}}"``list`为源数据数组，默认的数组元素名为`$item`；
*   `for="{{value in list}}"``value`为自定义的数组元素名，默认的数组元素索引名为`$idx`；
*   `for="{{(index, value) in list}}"``index`为自定义的数组元素索引名，`value`为自定义的数组元素名。

`for指令`的`tid属性`用于指定数组元素的唯一 Id，若未指定，默认使用数组索引(`$idx`)作为唯一 Id。`tid属性`的作用在于元素节点重用，优化 for 循环的重绘效率。

示例代码中，`tid="uniqueId"`表示使用数组`list`的数组元素`$item.uniqueId`作为数组元素的唯一 Id，且必须保证 uniqueId 这个属性值在每个数组元素都不一样。

使用`tid属性`时应注意：

*   `tid属性`指定的数据属性必须存在，否则可能导致运行异常；
*   `tid属性`指定的数据属性要保证唯一，否则可能导致性能问题；
*   `tid属性`目前不支持表达式。

## 条件渲染

`if/elif/else`节点必须是相邻的兄弟节点，否则无法通过编译。

```
<template>
  <div>
    <text if="{{display}}">Hello-1</text>
    <text elif="{{display}}">Hello-2</text>
    <text else>Hello-3</text>
  </div>
</template>

<script>
  export default {
    private: {
      display: false
    }
  }
</script>
```

```
<template>
  <text show="{{visible}}">Hello</text>
</template>

<script>
  export default {
    private: {
      visible: false
    }
  }
</script>
```

## 逻辑控制块

可以使用`<block>`实现更为灵活的循环/条件渲染；注意`<block>`目前只支持`for`和`if/elif/else`属性，如果没有指定任何属性，`<block>`则在构建时被当作`透明`节点对待，其子节点被添加到`<block>`的父节点上。

```
<template>
  <list>
    <block for="cities">
      <list-item type="city">
        <text>{{$item.name}}</text>
      </list-item>
      <list-item type="spot" for="$item.spots">
        <text>{{$item.address}}</text>
      </list-item>
    </block>
  </list>
</template>

<script>
  export default {
    private: {
      cities: [
        {
          name: 'beijing',
          spots: [
            { address: 'XXX' }
          ]
        },
        {
          name: 'shanghai',
          spots: [
            { address: 'XXX' },
            { address: 'XXX' }
          ]
        }
      ]
    }
  }
</script>
```

快速导航

数据绑定

事件绑定

列表渲染

条件渲染

逻辑控制块


---

## 注意事项.md

## 注意事项
========================================================================================================

## 手表中的异常场景

1.   网络异常，在没有网络的情况下提示
2.   数据异常（没有获取到数据，或者后端接口返回错误）处理
3.   JS代码错误处理
4.   按钮防止重复点击（点击后发请求的操作尤其要注意）
5.   息屏后重新亮屏会重新触发onShow生命周期函数，此生命周期函数中如果有fetch请求，亮屏时会再次发起请求，需谨慎使用

## 代码规范

1.   app.ux文件中的代码，必须写到`<script></script>`中，否则代码不会执行！
2.   *.ux文件中，`template`节点只能有一个根节点
3.   角度相关的css属性必须书写单位，比如`total-angle: 360deg`
4.   `list-item`中，谨慎使用`if`/`else`/`show`等条件判断，保证所有的`list-item`结构一致
5.   `image`的`src`属性不要使用变量拼接（比如 `src="/common/{{type}}`），否则编译器打包代码会显示警告，建议直接使用变量`src="{{imgPath}}"`

## 常见优化

1.   减少网络请求次数和并发数
2.   数据实时性要求不高的接口考虑做本地缓存（缓存也要考虑数据大小）
3.   控制本地文件数量，避免直接遍历文件获取所有文件大小
4.   尽可能使用低分辨率的网络图片
5.   列表使用分页，每一页保持在20个item以内比较好
6.   网络请求的数据，不要直接存储在内存中，只存储需要用到的字段
7.   谨慎使用三方依赖，使用轻量级的依赖
8.   公共代码可以考虑放到全局，不要多次引入
9.   添加loading态，防止按钮频繁点击后发起多次网络请求

手表中的异常场景

代码规范

常见优化


---

## 编写页面UI.md

## 功能需求

我们将要实现的天气预报App由两个页面组成：**实时天气**和**未来3天天气**。实时天气界面展示当前天气情况，主要包括天气、温度、湿度和能见度等信息。未来3天天气页面用于展示未来三天的天气情况。

最终要实现的效果图如下：

![Image 1: 实时天气](https://iot.mi.com/vela/quickapp/images/guide/ui-weather-now.png)![Image 2: 7天预报](https://iot.mi.com/vela/quickapp/images/guide/ui-weather-3d.png)

## 准备工作

这个App使用**和风天气API**获取天气数据，图标使用**和风天气图标**。

该使用指南中的天气App仅用于演示 Vela JS 应用开发技术，如需在实际项目中使用相关接口和资源，请到和风天气开发平台注册并开通接口后使用。详细信息可在官网查看：

*   和风天气开发平台: https://dev.qweather.com/(opens new window)
*   和风天气图标: https://icons.qweather.com/(opens new window)
*   图标下载地址: https://github.com/qwd/WeatherIcon(opens new window)

## 页面结构

在项目结构章节中，我们介绍了一个页面(ux文件)包含三部分：`template`、`style`和`script` 。接下来分别编写这两个页面的模板（`template`）代码。

##### 实时天气

实时天气页面，从整体上可以划分为上中下三部分： `header`、`body`和`footer`，代码如下。

温馨提示

template只能有一个根节点。

头部信息，包含城市、省份和国家信息，结构相对简单，代码如下：

温馨提示

天气信息部分，相比头部要稍微复杂一点，总体可以分为左右两列，右侧部分又分为上下两行。代码如下：

接下来实现体感温度等其他信息模块，整体上可以分为三列，每一列又分成两行，代码如下：

最后是底部更新时间模块，这个模块结构相对比较简单，代码如下：

##### 未来3天天气

这个页面跟实时天气页面整体结构相同，也分为上中下三部分，并且`header`以及`footer`内容一致，这里不再赘述。

接下来主要看中间部分的实现，主要包括**未来3天天气概况**以及**天气列表**。

天气概况分为上下两行，代码如下：

天气列表相对复杂一点，首先整体可以分为三列，每一列又可分成三行，代码如下：

## 页面样式

Vela支持常用的CSS特性，也进行了少量的扩充以及修改，默认支持对不同尺寸屏幕的适配。详细的属性支持情况可以在属性列表中查询。

Vela JS 应用采用`flex`布局，可以方便实现常用的布局样式，关于`flex`布局的技术细节，可以参考MDN文档(opens new window)。

目前只支持类选择器、ID选择器、分组选择器(,)和标签选择器，不支持后代选择器、属性选择器、通用选择器(*)、兄弟选择器(+)、直接父子选择器(>)、伪类和继承。

目前为止，我们已经完成了页面结构的代码编写，但是目前为止，还未涉及任何样式的设置。接下来我们将分别实现各个模块的样式。

##### 公共样式

编写样式代码之前，可以先提取出一些基础的公共样式，比如排列方式，颜色和对齐方式等。

在我们这个项目中，主要使用到了水平排列和垂直排列，居中等。 颜色方面，主要是白色，我们可以将text的颜色默认设置为白色。

提取出的基础样式为：

##### page

为了解决屏幕适配问题，所有与大小相关的样式（例如`width`、`font-size`）均以基准宽度（默认`480px`）为基础，根据实际屏幕宽度进行缩放，例如`width:100px`在`960px`宽度屏幕上，实际上为`200px`。

我们设计稿按照`480px`宽度进行设计，所以设计稿中的尺寸，可以直接在样式中使用。比如下图中，整体宽度为480，体感温度等信息模块的尺寸为`335*100`，那么CSS代码为：

![Image 3: 设计稿尺寸](https://iot.mi.com/vela/quickapp/images/guide/ui-figma-size.png)

对于整体页面，我们先将页面背景设置为黑色，形状设置为圆形，并设置页面宽度。

说明

如果设计稿基准宽度不是480，可以在`manifest.json`文件中通过`config.designWidth`字段配置：

##### 头部信息

头部信息竖向排列，并且居中，可以使用前面抽取的公共样式：`column`和`center`。然后给文本分别添加样式，控制字体大小和颜色。

修改后的模板代码如下：

CSS代码如下：

实际运行结果：

![Image 4: 头部信息运行结果](https://iot.mi.com/vela/quickapp/images/guide/ui-header.png)

##### 实时天气

添加完成后的模板代码如下：

体感温度等信息模块，首先水平方向排列(`flex-direction: row`)，然后各个item设置`flex: 1`，这样就实现了各个item宽度相等的效果。

具体到每个item里面，只需要分别设置各个文本字段的颜色和大小即可。

CSS代码如下：

实际运行结果：

![Image 5: 实时天气运行结果](https://iot.mi.com/vela/quickapp/images/guide/ui-now-main.png)

##### 未来3天天气

天气概况信息模块样式比较简单，竖向排列即可。

跟体感温度等信息模块类似，未来三天天气列表也使用水平方向排列。不同的地方在于，各个item有背景颜色并且之间有间距，所以给各个item设置了固定的尺寸，然后根据剩下的空间 给各个item之间分配间距(`justify-content: space-between`)。

修改完成后的模板代码为：

CSS代码为：

实际运行结果：

![Image 6: 实时天气运行结果](https://iot.mi.com/vela/quickapp/images/guide/ui-3d-list.png)

##### 底部信息

底部信息最终的模板代码如下：

CSS代码如下：

实际运行结果：

![Image 7: 实时天气运行结果](https://iot.mi.com/vela/quickapp/images/guide/ui-footer.png)

## 页面效果

完成页面结构和样式后，模拟器中实际运行的结果如下：

![Image 8: 实时天气运行结果](https://iot.mi.com/vela/quickapp/images/guide/ui-now-result.png)![Image 9: 未来3天天气运行结果](https://iot.mi.com/vela/quickapp/images/guide/ui-3d-result.png)

## 页面数据

我们已经实现了页面数据的渲染，但是目前所有的数据都是直接写到模板代码中，不能在程序中动态修改。

如果需要在程序中动态修改界面上展示的数据，需要将数据存储到页面数据对象中，然后使用双大括号语法来引用数据，比如`{{ name }}`，详细使用方法可以参考模板语法。

数据定义，需要通过JavaScript脚本来实现。跟HTML一样，JavaScript代码需要放在`script`标签中：

定义好数据之后，替换之前的模板代码，替换后为：

## 列表渲染

在未来3天天气预报页面中，使用到了数组存储未来3天的天气数据。可以使用`for`指令来渲染（详细的`for`指令用法，请参考列表渲染）。

数据定义为：

模板代码：

运行结果：

![Image 10: 列表渲染结果](https://iot.mi.com/vela/quickapp/images/guide/ui-for-list-result.png)

##### 条件渲染

实际项目中经常会需要使用到条件判断，根据不同的条件渲染不同的UI。要使用条件渲染，请参考条件指令。


---

## 编译参数.md

## 编译参数
==================================================================================================================

## 如何设置编译参数

通常有两种方式设置编译参数，以抽取单独的 source-map 文件为例：

*   在命令行携带编译参数

```
aiot build --devtool=source-map
```

*   在项目根目录新建配置文件 quickapp.config.js，并配置 cli 属性；

```
module.exports = {
  cli: {
    devtool: "source-map",
  },
};
```

## 查看当前工具支持的全部编译参数

```
npx aiot build -h
```

## 常见编译参数

| 参数名 | 值类型 | 描述 | 默认值 |
| --- | --- | --- | --- |
| --devtool | `string` | sourcemap 的输出形式， 参数值及含义可以参考 webpack/devtool(opens new window) 示例：`aiot server --devtool=source-map` | none |
| --enable-jsc | `boolean` | 是否将 js 文件将转换为 jsc 文件，以提高运行性能 示例：`aiot server --enable-jsc` | false |
| --enable-protobuf | `boolean` | 是否启用 protobuf 的二进制打包，以提高运行性能 示例：`aiot server --enable-protobuf` | false |

如何设置编译参数

常见编译参数


---

## 脚本语法.md

## script 脚本
====================================================================================================

ux 文件中用来定义页面的逻辑代码，包括数据对象、生命周期接口、自定义方法、通用方法等。

## 语法

支持 ES5 / ES6 语法

##### 模块声明

可以通过 import 引入功能模块，在代码中调用模块方法（具体参看接口部分文档说明）：

```
import fetch from '@system.fetch'
```

##### 代码引用

JS 代码引用推荐使用`import`来导入，例如：

```
import utils from '../common/utils.js'
```

注意

JS 应用环境不是 node 环境，不要引用 node 原生模块，如 `import fs from 'fs'`。

## 页面数据对象

页面文件中可以定义页面级的数据对象，用于在模板中绑定和在页面方法中操作。例如：

```
<template>
  <div>
    <text>{{a}}</text>
  </div>
</template>

<script>
  export default {
    // 页面的数据对象，影响传入数据的覆盖机制：private内定义的属性不允许被覆盖
    private: {
      a: 1
    }
  }
</script>
```

其他详细说明参见页面数据对象。

## 生命周期接口

应用和页面都有预定义的一系列生命周期，可在脚本中声明若干生命周期钩子函数，在执行到该特定生命周期阶段时，会调用这些钩子函数，例如：

```
// 会在应用/页面被初始化的时候执行这个函数
onInit() {
  console.log('page initialized！')
}
```

其他详细说明参见生命周期。

## 自定义方法

```
onBtnClick(){
  console.log('button clicked!')
}
```

## 全局对象和方法

开发者在应用ux文件(`app.ux`)中声明的属性和方法，可以在任意页面中通过`this.$app.$def`进行方法，详情参考全局对象和方法。

## 通用方法

快速导航

语法

模块声明

代码引用

页面数据对象

生命周期接口

自定义方法

全局对象和方法

通用方法


---

## 页面切换.md

## 页面切换

## 通过接口 router 切换页面和传递参数

##### 切换页面

router 接口在使用前，需要先导入模块。

通过`router.push(OBJECT)`可以完成页面切换，其支持的参数`uri`的格式详细描述参见页面路由。

**示例如下：**

```
<template>
  <div class="page">
    <input class="btn" type="button" value="跳转到新页面" onclick="routePage"></input>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .btn {
    width: 400px;
    height: 60px;
    margin-top: 70px;
    border-radius: 30px;
    background-color: #09ba07;
    font-size: 30px;
    color: #ffffff;
  }
</style>

<script>
  // 导入模块
  import router from '@system.router'

  export default {
    routePage () {
      // 跳转到应用内的某个页面，当前页面无法返回
      router.replace({
        uri: '/Pages/newPage'
      })
    }
  }
</script>
```

##### 传递参数

`router`接口的参数`params`可配置页面跳转时需要传递的参数。

**示例如下：**

```
<template>
  <div class="page">
    <input class="btn" type="button" value="携带参数跳转页面" onclick="routePageReplaceWithParams"></input>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .btn {
    width: 400px;
    height: 60px;
    margin-top: 70px;
    border-radius: 30px;
    background-color: #09ba07;
    font-size: 30px;
    color: #ffffff;
  }
</style>

<script>
  // 导入模块
  import router from '@system.router'

  export default {
    private: {
      title: 'Hello, world!'
    },

    onInit () {
      console.info('接口router切换页面并传递参数')
    },

    routePageReplaceWithParams () {
      // 跳转到应用内的某个页面
      router.replace({
        uri: '/PageParams/receiveparams',
        params: { key: this.title }
      })
    }
  }
</script>
```

## 接收参数

现在，开发者已经了解了通过接口`router`在页面之间传递参数的方法，如何接收参数呢？

其实很简单，接口`router`传递的参数的接收方法完全一致：在页面的 ViewModel 的`protected`属性中声明使用的属性。

注意

*   `protected`内定义的属性，允许被应用内部页面请求传递的数据覆盖，不允许被应用外部请求传递的数据覆盖
*   若希望参数允许被应用外部请求传递的数据覆盖，请在页面的 ViewModel 的`public`属性中声明使用的属性

**示例如下：**

```
<template>
  <div class="page">
    <text>page</text>
    <!-- template中显示页面传递的参数 -->
    <text>{{key}}</text>
  </div>
</template>

<style>
  .page {
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
</style>

<script>
  export default {
    protected: {
      key: ''
    },
    onInit () {
      // js中输出页面传递的参数
      console.info('key: ' + this.key)
    }
  }
</script>
```


---

## 页面启动模式.md

## 页面启动模式

用于定义页面的启动行为。

## 静态声明

在 manifest 文件中页面路由信息 router.page 可增加启动模式字段 launchMode，用于声明该页面的启动模式。

##### 页面启动模式参数：

| 属性 | 类型 | 默认值 | 必填 | 描述 |
| --- | --- | --- | --- | --- |
| launchMode | String | standard | 否 | 声明页面的启动模式，支持"singleTask"，"standard"两种页面启动模式。 标识为"singleTask"模式时每次打开目标页面都会打开已有的目标页面并回调 onRefresh 生命周期函数，清除该页面上打开的其他页面，没有打开过此页面时会创建新的目标页面实例。 标识为"standard"模式时会每次打开新的目标页面（多次打开目标页面地址时会存在多个相同页面） |

##### 示例：

打开页面的行为逻辑：

若按顺序启动 PageA -> PageB -> PageC -> PageB -> PageC -> PageA

*   打开 PageA，首次打开时页面栈为空 页面栈为PageA
*   打开 PageB，PageB 的启动模式为 standard，即在 PageA 之上新建 PageB 的页面实例并显示 页面栈为PageA,PageB
*   打开 PageC，首次打开 PageC，即在 PageB 之上新建 PageC 的页面实例并显示 页面栈为PageA,PageB,PageC
*   打开 PageB，PageB 的启动模式为 standard，即在 PageC 之上新建 PageB 的页面实例并显示 页面栈为PageA,PageB,PageC,PageB
*   打开 PageC，PageC 页面实例已存在，即销毁 PageC 之上的页面实例 PageB，回到之前打开的 PageC 的页面实例并回调此页面生命周期的 onRefresh 函数 页面栈为PageA,PageB,PageC
*   打开 PageA，PageA 页面实例已存在，即销毁 PageA 之上的页面实例 PageB 和 PageC，回到之前打开的 PageA 的页面实例并回调此页面生命周期的 onRefresh 函数 页面栈为PageA

## 动态声明

动态声明有两种方式。一种是在 router.push 中携带启动标识参数，另一种是在打开页面的链接中携带启动标识参数。启动标识参数可以控制页面打开行为。

##### 页面启动模式参数：

| 参数 | 类型 | 必填 | 说明 |
| --- | --- | --- | --- |
| ___PARAM_LAUNCH_FLAG___ | String | 否 | 跳转 JS 应用页面时传递的页面参数。携带 clearTask 时启动目标页面会清除此页面外的其他页面，存在多个目标页面时只保留最先打开的目标页面并回调 onRefresh 生命周期。如不存在目标页面时将清除所有页面并新建目标页面实例 |

##### 示例：

打开页面的行为逻辑：

若已经打开页面栈为 PageA -> PageB -> PageC，此时以 clearTask 标识启动 PageB

*   销毁 PageC 页面实例
*   销毁 PageA 页面实例
*   PageB 页面实例已存在，回到此页面实例并回调此页面生命周期的 onRefresh 函数

若已经打开页面栈为 PageA -> PageC，此时以 clearTask 标识启动 PageB

*   销毁 PageC 页面实例
*   销毁 PageA 页面实例
*   PageB 页面实例不存在，新建 PageB 页面实例并显示


---

## 项目结构.md

## 项目结构

## 应用资源

一个应用包含：描述项目配置信息的manifest 文件，放置项目公共资源脚本的app.ux 文件，多个描述页面的ux 文件，典型示例如下：

应用根目录：

## ux模板

一个页面通常都由三部分组成：页面结构、样式和逻辑交互。这三部分，可以放在一个ux文件中，也可以作为独立的文件。

如果放在一个ux文件中，则ux文件需要包含三标签：`template`、`style`和`script`。

示例：

如果将页面结构、样式和逻辑交互分开作为独立的文件，可以使用如下目录结构：

说明

如果作为独立的文件，将ux/css/js文件分开后，ux文件中不能包含`template`标签。

## 文件存储

在应用平台中是按分区来存储文件的，目前支持以下分区：

1.   Cache，一般用于存储缓存文件，比如通过 fetch 接口下载的文件会存储在该分区中，该分区中的文件可能因存储空间不够被系统删除；
2.   Files，一般用于存储比较小的永久文件，该分区中的文件由应用自己管理；
3.   Mass，一般用于存储比较大的文件，但该分区并不保证一直可用；
4.   Temp，表示从外部映射过来的临时文件，出于安全性考虑，临时文件是只读的，并且只能通过调用特定的 API 获取，比如 file.readText 方法。另外临时文件的访问是临时的，应用重启后无法访问到临时文件，需要通过特定 API 重新获取。

另外应用资源也作为一个特殊的只读分区进行处理。

## URI

| 资源类型 | URI | 只读 | 示例 | 说明 |
| --- | --- | --- | --- | --- |
| 应用资源 | /path | 是 | /Common/header.png | - |
| Cache | internal://cache/path | 否 | internal://cache/fetch-123456.png | - |
| Files | internal://files/path | 否 | internal://files/image/demo.png | - |
| Mass | internal://mass/path | 否 | internal://mass/video/demo.mp4 | - |
| Temp | internal://tmp/path | 是 | internal://tmp/xxxxx | 由系统动态生成 |

URI 允许的字符是`0-9a-zA-Z_-./%:`(不包含引号)，URI 中不能出现`..`，URI 支持目录结构，目录由斜线'/'分隔。

internal URI 表示的是应用私有文件，即在指定 internal URI 时，无需指定应用标识，同一个 internal URI 对于不同的应用会指向不同的文件。

## 资源和文件访问规则

应用资源路径分为绝对路径和相对路径，以"/"开头的路径表示绝对路径，比如 /Common/a.png，不以"/"开头的路径是相对路径，比如 a.png 和 ../Common/a.png 等。

应用资源文件分为代码文件和资源文件，代码文件是指 .js/.css/.ux 等包含代码的文件，其他文件则是资源文件，这类文件一般只当作数据来使用，比如图片、视频等。

1.   在代码文件中，导入其他代码文件时，使用相对路径，比如：../Common/component.ux；
2.   在代码文件中，引用资源文件(如：图片、视频等)时，一般情况下使用相对路径，比如：./abc.png；
3.   当代码文件需要被导入时，如果导入文件与被导入文件在同一个目录，被导入文件引用资源文件时可以使用相对路径，但如果不在同一目录，必须使用绝对路径，因为被导入文件编译时会被复制到导入文件中，编译后目录会发生变化。比如 a.css 文件被 b.ux 导入，如果 a.css 与 b.ux 在同一个目录，a.css 引用资源文件时可以写相对路径：abc.png，如果不在同一个目录，必须写绝对路径：/Common/abc.png，再比如当 a.ux 文件被 b.ux 文件导入时，如果 a.ux 与 b.ux 在同一个目录，a.ux 引用资源文件时可以写相对路径：a.png，如果不在同一个目录，a.ux 引用资源必须写绝对路径：/Common/abc.png；
4.   在 CSS 中，与前端开发一致，使用 url(PATH)的方式访问资源文件，如：url(/Common/abc.png)。


---

## 项目配置.md

## 项目配置

`manifest.json`文件中包含了应用描述、接口声明、页面路由信息。

## manifest

| 属性 | 类型 | 默认值 | 必填 | 描述 |
| --- | --- | --- | --- | --- |
| package | String | - | 是 | 应用包名，**确认与原生应用的包名不一致**，推荐采用 com.company.module 的格式，如：com.example.demo |
| name | String | - | 是 | 应用名称，**6 个汉字以内，与应用商店保存的名称一致**，用于在桌面图标、弹窗等处显示应用名称 |
| icon | String | - | 是 | 应用图标，提供 192x192 大小的即可 |
| versionName | String | - | 否 | 应用版本名称，如："1.0" |
| versionCode | Integer | - | 是 | 应用版本号，从`1`自增，**推荐每次重新上传包时`versionCode`+1** |
| minAPILevel | Integer | 1 | 否 | 支持的最小 API 标准版本号，**兼容性检查，避免上线后在低版本平台运行并导致不兼容**；如果不填按照内测版本处理 |
| features | Array | - | 否 | 接口列表，绝大部分接口都需要在这里声明，否则不能调用，详见每个接口的文档说明 |
| config | Object | - | 是 | 系统配置信息，详见下面说明 |
| router | Object | - | 是 | 路由信息，详见下面说明 |
| display | Object | - | 否 | UI 显示相关配置，详见下面说明 |
| deviceTypeList | Array<String> | watch | 否 | 可选值有：watch、tv、car、phone，现只支持watch |
| permissions | Array | - | 否 | 权限申请，示例：[{ "name": "hapjs.permission.LOCATION" }] |

##### config

用于定义系统配置和全局数据。

| 属性 | 类型 | 默认值 | 描述 |
| --- | --- | --- | --- |
| logLevel | String | log | 打印日志等级，分为 off、error、warn、info、log、debug |
| designWidth | Integer | - | 页面设计基准宽度，根据实际设备宽度来缩放元素大小 |
| background | Object | - | 后台运行配置信息，可使用 features 字段申请需要在后台使用的接口（同时仍需在最外层的 features 字段中声明）。可申请的接口为： system.audio system.geolocation system.request 等 详细用法参见 后台运行 脚本 |

##### minAPILevel

支持的最小 API 标准版本号，标识开发者的 rpk 包能兼容运行在最小实现了该版本 API 标准的设备上，其值默认为1。当使用了 1 及以上的 API 标准版本新增特性时，就必须确保 minAPILevel 最低为该版本号，避免上线后在实现了更低版本 API 标准的设备上运行出错。

示例如下：

##### router

用于定义页面的组成和相关配置信息，如果页面没有配置路由信息，则在编译打包时跳过。

| 属性 | 类型 | 默认值 | 必填 | 描述 |
| --- | --- | --- | --- | --- |
| entry | String | - | 是 | 首页名称，使用分包功能时，建议将首页定义在基础包 |
| pages | Object | - | 是 | 页面配置列表，key 值为页面名称（对应页面目录名，例如 Hello 对应'Hello'目录），value 为页面详细配置 page，详见下面说明 |

示例代码：

###### router.pages

用于定义单个页面路由信息。

| 属性 | 类型 | 默认值 | 必填 | 描述 |
| --- | --- | --- | --- | --- |
| path | String | /<页面名称> | 否 | 页面路径，例如"/user",不填则默认为/<页面名称> path 必须唯一，不能和其他 page 的 path 相同 下面 page 的 path 因为缺失，会被设置为"/Index"： `"Index": {"component": "index"}` |
| launchMode | String | standard | 否 | 声明页面的启动模式，支持"singleTask"，"standard"两种页面启动模式 标识为"singleTask"模式时每次打开目标页面都会打开已有的目标页面并回调 onRefresh 生命周期函数，清除该页面上打开的其他页面，没有打开过此页面时会创建新的目标页面实例 标识为"standard"模式时会每次打开新的目标页面（多次打开目标页面地址时会存在多个相同页面） |

##### 示例代码

##### display

用于定义与 UI 显示相关的配置。

如果在 display 对象下定义以下属性值，则生效范围为此JS 应用全部页面；

| 属性 | 类型 | 默认值 | 描述 |
| --- | --- | --- | --- |
| backgroundColor | String | #ffffff | 窗口背景颜色 |

##### 权限说明

| 权限名 | feature | api | 描述 | 权限错误码 |
| --- | --- | --- | --- | --- |
| hapjs.permission.LOCATION | system.geolocation | getLocation subscribe unsubscribe | 地理位置 | 400： 拒绝授予权限 402： 权限错误（未声明该权限） |
| hapjs.permission.DEVICE_INFO | system.device | getSerial getDeviceId | 获取设备信息 | 400： 拒绝授予权限 402： 权限错误（未声明该权限） |

